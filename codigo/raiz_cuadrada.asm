.include "m328pdef.inc"

.DEF DIVIDENDO_4toBYTE = R6
.DEF DIVIDENDO_3erBYTE = R7
.DEF DIVIDENDO_2doBYTE = R8
.DEF DIVIDENDO_1erBYTE = R9
.DEF DIVISOR_4toBYTE = R10
.DEF DIVISOR_3erBYTE = R11
.DEF DIVISOR_2doBYTE = R12
.DEF DIVISOR_1erBYTE = R13
.DEF COCIENTE_4toBYTE = R14
.DEF COCIENTE_3erBYTE = R15
.DEF COCIENTE_2doBYTE = R16
.DEF COCIENTE_1erBYTE = R17
.DEF FALTA_RESTA = R18
.DEF CUADRADO_4toBYTE = R22
.DEF CUADRADO_3erBYTE = R23
.DEF CUADRADO_2doBYTE = R24
.DEF CUADRADO_1erBYTE = R25
.DEF INIT_CUADRADO_4toBYTE = R26
.DEF INIT_CUADRADO_3erBYTE = R27
.DEF INIT_CUADRADO_2doBYTE = R28
.DEF INIT_CUADRADO_1erBYTE = R29
.DEF TEMP = R30
.DEF CONT_ITERACIONES = R31

.CSEG
	RJMP MAIN

.EQU CANT_ITERACIONES = 5
.EQU FALTA_RESTA_4toBYTE = 2
.EQU FALTA_RESTA_3erBYTE = 1
.EQU FALTA_RESTA_2doBYTE = 0

.ORG INT_VECTORS_SIZE

MAIN:
;INICIALIZACION STACK
	LDI TEMP,HIGH(RAMEND)
	OUT SPH,TEMP
	LDI TEMP,LOW(RAMEND)
	OUT SPL,R16
;[FIN]INICIALIZACION STACK

	CLR TEMP
	LDI CONT_ITERACIONES,CANT_ITERACIONES;CARGO LA CANTIDAD DE ITERACIONES

	LDI CUADRADO_4toBYTE,0x00
	LDI CUADRADO_3erBYTE,0x00
	LDI CUADRADO_2doBYTE,0x33
	LDI CUADRADO_1erBYTE,0xA4

	LDI INIT_CUADRADO_2doBYTE,0x00;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO
	LDI INIT_CUADRADO_1erBYTE,0xFF;GUARDO EL VALOR DEL 3er BYTE DEL CUADRADO

/*
	MOV INIT_CUADRADO_4toBYTE,CUADRADO_4toBYTE;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO
	MOV INIT_CUADRADO_3erBYTE,CUADRADO_3erBYTE;GUARDO EL VALOR DEL 3er BYTE DEL CUADRADO
	MOV INIT_CUADRADO_2doBYTE,CUADRADO_2doBYTE;GUARDO EL VALOR DEL 2do BYTE DEL CUADRADO
	MOV INIT_CUADRADO_1erBYTE,CUADRADO_1erBYTE;GUARDO EL VALOR DEL 1er BYTE DEL CUADRADO
	;DIVIDO POR DOS EL CUADRADO PARA TENER X(0) = a/2
	LSR INIT_CUADRADO_4toBYTE
	ROR INIT_CUADRADO_3erBYTE
	ROR INIT_CUADRADO_2doBYTE
	ROR INIT_CUADRADO_1erBYTE
	;[FIN]DIVIDO POR DOS EL CUADRADO PARA TENER X(0) = a/2
*/
ITERACION_RAIZ:
	CALL RAIZ_NR
	DEC CONT_ITERACIONES
	BRNE ITERACION_RAIZ
HERE:RJMP HERE

RAIZ_NR:
	;a
	MOVW DIVIDENDO_3erBYTE:DIVIDENDO_4toBYTE,CUADRADO_3erBYTE:CUADRADO_4toBYTE
	MOVW DIVIDENDO_1erBYTE:DIVIDENDO_2doBYTE,CUADRADO_1erBYTE:CUADRADO_2doBYTE
	;[FIN]a
	;X(k)
	MOVW DIVISOR_3erBYTE:DIVISOR_4toBYTE,INIT_CUADRADO_3erBYTE:INIT_CUADRADO_4toBYTE
	MOVW DIVISOR_1erBYTE:DIVISOR_2doBYTE,INIT_CUADRADO_1erBYTE:INIT_CUADRADO_2doBYTE
	;[FIN]X(k)
	CALL DIVISION;a/X(k)
	;X(k) + a/X(k)
	ADD INIT_CUADRADO_1erBYTE,COCIENTE_1erBYTE
	ADC INIT_CUADRADO_2doBYTE,COCIENTE_2doBYTE
	ADC INIT_CUADRADO_3erBYTE,COCIENTE_3erBYTE
	ADC INIT_CUADRADO_4toBYTE,COCIENTE_4toBYTE
	;[FIN]X(k) + a/X(k)
	;(X(k) + a/X(k))/2
	LSR INIT_CUADRADO_4toBYTE
	ROR INIT_CUADRADO_3erBYTE
	ROR INIT_CUADRADO_2doBYTE
	ROR INIT_CUADRADO_1erBYTE
	;[FIN](X(k) + a/X(k))/2
RET

DIVISION:
	CLR COCIENTE_4toBYTE
	CLR COCIENTE_3erBYTE
	CLR COCIENTE_2doBYTE
	CLR COCIENTE_1erBYTE
RESTA_1erBYTE:
	LDI TEMP,1
	ORI FALTA_RESTA,(1<<FALTA_RESTA_2doBYTE)|(1<<FALTA_RESTA_3erBYTE)|(1<<FALTA_RESTA_4toBYTE);AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 2do, 3er o 4to BYTE
	SUB DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;LE RESTO AL 1er BYTE DEL DIVIDENDO EL 1er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_2doBYTE;SI EL 1er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 2do BYTE
RESTA_2doBYTE:
	ANDI FALTA_RESTA,~(1<<FALTA_RESTA_2doBYTE);AVISO QUE SE REALIZO LA RESTA DEL 2do BYTE
	SUB DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;LE RESTO AL 2do BYTE DEL DIVIDENDO EL 2do BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 3er BYTE
RESTA_3erBYTE:
	ANDI FALTA_RESTA,~(1<<FALTA_RESTA_3erBYTE);AVISO QUE SE REALIZO LA RESTA DEL 3er BYTE
	SUB DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;LE RESTO AL 3er BYTE DEL DIVIDENDO EL 3er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 4to BYTE
RESTA_4toBYTE:
	ANDI FALTA_RESTA,~(1<<FALTA_RESTA_4toBYTE);AVISO QUE SE REALIZO LA RESTA DEL 4to BYTE
	SUB DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;LE RESTO AL 4to BYTE DEL DIVIDENDO EL 4to BYTE DEL DIVIDENDO
	BRCS REDONDEO;SI EL 4to BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO

INCREMENTAR_RESULTADO:
	LDI TEMP,1
	ADD COCIENTE_1erBYTE,TEMP;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	CLR TEMP
	ADC COCIENTE_2doBYTE,TEMP;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,TEMP;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,TEMP;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR
	RJMP RESTA_1erBYTE;VUELVO A COMENZAR EL PROCESO DE DIVISION

PEDIDO_CARRY_2doBYTE:
	CLR TEMP
	CP DIVIDENDO_2doBYTE,TEMP;REVISO SI EL 2do BYTE ES NULO
	BRNE CARRY_2doBYTE;SI EL 2do BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 3er BYTE
CARRY_2doBYTE:
	DEC DIVIDENDO_2doBYTE;RESTO EN UNO EL 2do BYTE
	RJMP RESTA_2doBYTE;VUELVO A LAS RESTAS SUCESIVAS

PEDIDO_CARRY_3erBYTE:
	CLR TEMP
	CP DIVIDENDO_3erBYTE,TEMP;REVISO SI EL 3er BYTE ES NULO
	BRNE CARRY_3erBYTE;SI EL 3er BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 4to BYTE
CARRY_3erBYTE:
	DEC DIVIDENDO_3erBYTE;RESTO EN UNO EL 3er BYTE
	SBRC FALTA_RESTA,FALTA_RESTA_2doBYTE;REVISO SI QUEDO PENDIENTE LA RESTA DEL 2do BYTE
	RJMP CARRY_2doBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_3erBYTE;VUELVO LAS RESTAS SUCESIVAS

PEDIDO_CARRY_4toBYTE:
	CLR TEMP
	CP DIVIDENDO_4toBYTE,TEMP;REVISO SI EL 4to BYTE ES NULO
	BRNE CARRY_4toBYTE;SI EL 4to BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP REDONDEO;SI EL 4to BYTE ES NULO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO
CARRY_4toBYTE:
	DEC DIVIDENDO_4toBYTE;RESTO EN UNO EL 4to BYTE
	SBRC FALTA_RESTA,FALTA_RESTA_2doBYTE;REVISO SI QUEDO PENDIENTE LA RESTA DEL 2do BYTE
	RJMP CARRY_3erBYTE;VUELVO AL CARRY DEL 3er BYTE
	RJMP RESTA_4toBYTE;VUELVO LAS RESTAS SUCESIVAS

REDONDEO:
	ADD DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;REESTABLEZCO EL VALOR DEL 1er BYTE ANTES DE RESTARLO DE MAS
REVISAR_2doBYTE:
	SBRC FALTA_RESTA,FALTA_RESTA_2doBYTE;REVISO SI QUEDO PENDIENTE LA RESTA DEL 2do BYTE
	RJMP REVISAR_3erBYTE;SI NO HICE UNA RESTA DE MAS EN EL 2do BYTE, PROCEDO A REVISAR EN EL 3er BYTE
	ADD DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;REESTABLEZCO EL VALOR DEL 2do BYTE ANTES DE RESTARLO DE MAS
REVISAR_3erBYTE:
	SBRC FALTA_RESTA,FALTA_RESTA_3erBYTE;REVISO SI QUEDO PENDIENTE LA RESTA DEL 3er BYTE
	RJMP REVISAR_4toBYTE;SI NO HICE UNA RESTA DE MAS EN EL 3er BYTE, PROCEDO A REVISAR EN EL 4to BYTE
	ADD DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;REESTABLEZCO EL VALOR DEL 3er BYTE ANTES DE RESTARLO DE MAS
REVISAR_4toBYTE:
	SBRC FALTA_RESTA,FALTA_RESTA_4toBYTE;REVISO SI QUEDO PENDIENTE LA RESTA DEL 4to BYTE
	RJMP CHEQUEAR_REDONDEO;SI NO HICE UNA RESTA DE MAS EN EL 4to BYTE, PROCEDO A COMENZAR EL REDONDEO
	ADD DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;REESTABLEZCO EL VALOR DEL 4to BYTE ANTES DE RESTARLO DE MAS

CHEQUEAR_REDONDEO:
	;DIVIDO POR DOS EL DIVISOR
	LSR DIVISOR_4toBYTE
	ROR DIVISOR_3erBYTE
	ROR DIVISOR_2doBYTE
	ROR DIVISOR_1erBYTE
	;[FIN]DIVIDO POR DOS EL DIVISOR
	;CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
	CP DIVIDENDO_4toBYTE,DIVISOR_4toBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_3erBYTE,DIVISOR_3erBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_2doBYTE,DIVISOR_2doBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_1erBYTE,DIVISOR_1erBYTE
	BRPL MODIFICAR_COCIENTE
	RJMP RETIRADA
	;[FIN]CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
MODIFICAR_COCIENTE:;SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR, REDONDEO PARA ARRIBA EL COCIENTE
	LDI TEMP,1
	ADD COCIENTE_1erBYTE,TEMP;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	CLR TEMP
	ADC COCIENTE_2doBYTE,TEMP;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,TEMP;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,TEMP;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR

RETIRADA:
RET;SI EL RESTO ES MENOR O IGUAL A LA MITAD DEL DIVISOR, TERMINO LA DIVISION POR COMPLETO
