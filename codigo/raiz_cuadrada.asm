.include "m328pdef.inc"

.DEF REG_VACIO = R1
.DEF FALTA_RESTA_2doBYTE = R2
.DEF FALTA_RESTA_3erBYTE = R3
.DEF FALTA_RESTA_4toBYTE = R4
.DEF REG_UNO = R5
.DEF REDONDEO_4toBYTE = R6
.DEF REDONDEO_3erBYTE = R7
.DEF REDONDEO_2doBYTE = R8
.DEF REDONDEO_1erBYTE = R9
.DEF DIVISOR_4toBYTE = R10
.DEF DIVISOR_3erBYTE = R11
.DEF DIVISOR_2doBYTE = R12
.DEF DIVISOR_1erBYTE = R13
.DEF COCIENTE_4toBYTE = R14
.DEF COCIENTE_3erBYTE = R15
.DEF COCIENTE_2doBYTE = R16
.DEF COCIENTE_1erBYTE = R17
.DEF DIVIDENDO_4toBYTE = R18
.DEF DIVIDENDO_3erBYTE = R19
.DEF DIVIDENDO_2doBYTE = R20
.DEF DIVIDENDO_1erBYTE = R21
.DEF CUADRADO_4toBYTE = R22
.DEF CUADRADO_3erBYTE = R23
.DEF CUADRADO_2doBYTE = R24
.DEF CUADRADO_1erBYTE = R25
.DEF INIT_CUADRADO_4toBYTE = R26
.DEF INIT_CUADRADO_3erBYTE = R27
.DEF INIT_CUADRADO_2doBYTE = R28
.DEF INIT_CUADRADO_1erBYTE = R29
.DEF TEMP = R30
.DEF CONT_ITERACIONES = R31

.CSEG
	RJMP MAIN

.EQU CANT_ITERACIONES = 20

.ORG INT_VECTORS_SIZE

MAIN:
;INICIALIZACION STACK
	LDI TEMP,HIGH(RAMEND)
	OUT SPH,TEMP
	LDI TEMP,LOW(RAMEND)
	OUT SPL,R16
;[FIN]INICIALIZACION STACK

	CLR REG_VACIO;VALOR NULO
	CLR REG_UNO
	INC REG_UNO;CARGO UN VALOR CON 1
	CLR TEMP
	LDI CONT_ITERACIONES,CANT_ITERACIONES;CARGO LA CANTIDAD DE ITERACIONES

	LDI CUADRADO_4toBYTE,0x32
	LDI CUADRADO_3erBYTE,0x12
	LDI CUADRADO_2doBYTE,0x23
	LDI CUADRADO_1erBYTE,0x42

	MOV INIT_CUADRADO_4toBYTE,CUADRADO_4toBYTE;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO
	MOV INIT_CUADRADO_3erBYTE,CUADRADO_3erBYTE;GUARDO EL VALOR DEL 3er BYTE DEL CUADRADO
	MOV INIT_CUADRADO_2doBYTE,CUADRADO_2doBYTE;GUARDO EL VALOR DEL 2do BYTE DEL CUADRADO
	MOV INIT_CUADRADO_1erBYTE,CUADRADO_1erBYTE;GUARDO EL VALOR DEL 1er BYTE DEL CUADRADO
	;DIVIDO POR DOS EL CUADRADO PARA TENER X(0) = a/2
	LSR INIT_CUADRADO_4toBYTE
	ROR INIT_CUADRADO_3erBYTE
	ROR INIT_CUADRADO_2doBYTE
	ROR INIT_CUADRADO_1erBYTE
	;[FIN]DIVIDO POR DOS EL CUADRADO PARA TENER X(0) = a/2

ITERACION_RAIZ:
	CALL RAIZ_NR
	DEC CONT_ITERACIONES
	BRNE ITERACION_RAIZ
HERE:RJMP HERE

RAIZ_NR:
	;a
	MOV DIVIDENDO_4toBYTE,CUADRADO_4toBYTE
	MOV DIVIDENDO_3erBYTE,CUADRADO_3erBYTE
	MOV DIVIDENDO_2doBYTE,CUADRADO_2doBYTE
	MOV DIVIDENDO_1erBYTE,CUADRADO_1erBYTE
	;[FIN]a
	;X(k)
	MOV DIVISOR_4toBYTE,INIT_CUADRADO_4toBYTE
	MOV DIVISOR_3erBYTE,INIT_CUADRADO_3erBYTE
	MOV DIVISOR_2doBYTE,INIT_CUADRADO_2doBYTE
	MOV DIVISOR_1erBYTE,INIT_CUADRADO_1erBYTE
	;[FIN]X(k)
	CALL DIVISION;a/X(k)
	;X(k) + a/X(k)
	ADD INIT_CUADRADO_1erBYTE,COCIENTE_1erBYTE
	ADC INIT_CUADRADO_2doBYTE,COCIENTE_2doBYTE
	ADC INIT_CUADRADO_3erBYTE,COCIENTE_3erBYTE
	ADC INIT_CUADRADO_4toBYTE,COCIENTE_4toBYTE
	;[FIN]X(k) + a/X(k)
	;(X(k) + a/X(k))/2
	LSR INIT_CUADRADO_4toBYTE
	ROR INIT_CUADRADO_3erBYTE
	ROR INIT_CUADRADO_2doBYTE
	ROR INIT_CUADRADO_1erBYTE
	;[FIN](X(k) + a/X(k))/2
RET

DIVISION:
	CLR COCIENTE_4toBYTE
	CLR COCIENTE_3erBYTE
	CLR COCIENTE_2doBYTE
	CLR COCIENTE_1erBYTE
RESTA_1erBYTE:
	ADD FALTA_RESTA_2doBYTE,REG_UNO;AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 2do BYTE
	ADD FALTA_RESTA_3erBYTE,REG_UNO;AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 3er BYTE
	ADD FALTA_RESTA_4toBYTE,REG_UNO;AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 4to BYTE
	SUB DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;LE RESTO AL 1er BYTE DEL DIVIDENDO EL 1er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_2doBYTE;SI EL 1er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 2do BYTE
RESTA_2doBYTE:
	CLR FALTA_RESTA_2doBYTE;AVISO QUE SE REALIZO LA RESTA DEL 2do BYTE
	SUB DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;LE RESTO AL 2do BYTE DEL DIVIDENDO EL 2do BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 3er BYTE
RESTA_3erBYTE:
	CLR FALTA_RESTA_3erBYTE;AVISO QUE SE REALIZO LA RESTA DEL 3er BYTE
	SUB DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;LE RESTO AL 3er BYTE DEL DIVIDENDO EL 3er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 4to BYTE
RESTA_4toBYTE:
	CLR FALTA_RESTA_4toBYTE;AVISO QUE SE REALIZO LA RESTA DEL 4to BYTE
	SUB DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;LE RESTO AL 4to BYTE DEL DIVIDENDO EL 4to BYTE DEL DIVIDENDO
	BRCS REDONDEO;SI EL 4to BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO

INCREMENTAR_RESULTADO:
	ADD COCIENTE_1erBYTE,REG_UNO;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	ADC COCIENTE_2doBYTE,REG_VACIO;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,REG_VACIO;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,REG_VACIO;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR
	RJMP RESTA_1erBYTE;VUELVO A COMENZAR EL PROCESO DE DIVISION

PEDIDO_CARRY_2doBYTE:
	CPI DIVIDENDO_2doBYTE,0;REVISO SI EL 2do BYTE ES NULO
	BRNE CARRY_2doBYTE;SI EL 2do BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 3er BYTE
CARRY_2doBYTE:
	DEC DIVIDENDO_2doBYTE;RESTO EN UNO EL 2do BYTE
	RJMP RESTA_2doBYTE;VUELVO A LAS RESTAS SUCESIVAS

PEDIDO_CARRY_3erBYTE:
	CPI DIVIDENDO_3erBYTE,0;REVISO SI EL 3er BYTE ES NULO
	BRNE CARRY_3erBYTE;SI EL 3er BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 4to BYTE
CARRY_3erBYTE:
	DEC DIVIDENDO_3erBYTE;RESTO EN UNO EL 3er BYTE
	CP FALTA_RESTA_2doBYTE,REG_VACIO;REVISO SI QUEDO PENDIENTE LA RESTA DEL 2do BYTE
	BRNE CARRY_2doBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_3erBYTE;VUELVO LAS RESTAS SUCESIVAS

PEDIDO_CARRY_4toBYTE:
	CPI DIVIDENDO_4toBYTE,0;REVISO SI EL 4to BYTE ES NULO
	BRNE CARRY_4toBYTE;SI EL 4to BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP REDONDEO;SI EL 4to BYTE ES NULO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO
CARRY_4toBYTE:
	DEC DIVIDENDO_4toBYTE;RESTO EN UNO EL 4to BYTE
	CP FALTA_RESTA_3erBYTE,REG_VACIO;REVISO SI QUEDO PENDIENTE LA RESTA DEL 3er BYTE
	BRNE CARRY_3erBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_4toBYTE;VUELVO LAS RESTAS SUCESIVAS

REDONDEO:
	ADD DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;REESTABLEZCO EL VALOR DEL 1er BYTE ANTES DE RESTARLO DE MAS
REVISAR_2doBYTE:
	CP FALTA_RESTA_2doBYTE,REG_VACIO;REVISO SI HICE UNA RESTA DE MAS EN EL 2do BYTE
	BRNE REVISAR_3erBYTE;SI NO HICE UNA RESTA DE MAS EN EL 2do BYTE, PROCEDO A REVISAR EN EL 3er BYTE
	ADD DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;REESTABLEZCO EL VALOR DEL 2do BYTE ANTES DE RESTARLO DE MAS
REVISAR_3erBYTE:
	CP FALTA_RESTA_3erBYTE,REG_VACIO;REVISO SI HICE UNA RESTA DE MAS EN EL 3er BYTE
	BRNE REVISAR_4toBYTE;SI NO HICE UNA RESTA DE MAS EN EL 3er BYTE, PROCEDO A REVISAR EN EL 4to BYTE
	ADD DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;REESTABLEZCO EL VALOR DEL 3er BYTE ANTES DE RESTARLO DE MAS
REVISAR_4toBYTE:
	CP FALTA_RESTA_4toBYTE,REG_VACIO;REVISO SI HICE UNA RESTA DE MAS EN EL 4to BYTE
	BRNE CHEQUEAR_REDONDEO;SI NO HICE UNA RESTA DE MAS EN EL 3er BYTE, PROCEDO A COMENZAR EL REDONDEO
	ADD DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;REESTABLEZCO EL VALOR DEL 4to BYTE ANTES DE RESTARLO DE MAS

CHEQUEAR_REDONDEO:
	MOV REDONDEO_4toBYTE,DIVISOR_4toBYTE;GUARDO EL VALOR DEL 4to BYTE DEL DIVISOR
	MOV REDONDEO_3erBYTE,DIVISOR_3erBYTE;GUARDO EL VALOR DEL 3er BYTE DEL DIVISOR
	MOV REDONDEO_2doBYTE,DIVISOR_2doBYTE;GUARDO EL VALOR DEL 2do BYTE DEL DIVISOR
	MOV REDONDEO_1erBYTE,DIVISOR_1erBYTE;GUARDO EL VALOR DEL 1er BYTE DEL DIVISOR
	;DIVIDO POR DOS EL DIVISOR
	LSR REDONDEO_4toBYTE
	ROR REDONDEO_3erBYTE
	ROR REDONDEO_2doBYTE
	ROR REDONDEO_1erBYTE
	;[FIN]DIVIDO POR DOS EL DIVISOR
	;CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
	CP DIVIDENDO_4toBYTE,REDONDEO_4toBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_3erBYTE,REDONDEO_3erBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_2doBYTE,REDONDEO_2doBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_1erBYTE,REDONDEO_1erBYTE
	BRPL MODIFICAR_COCIENTE
	RJMP RETIRADA
	;[FIN]CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
MODIFICAR_COCIENTE:;SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR, REDONDEO PARA ARRIBA EL COCIENTE
	ADD COCIENTE_1erBYTE,REG_UNO;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	ADC COCIENTE_2doBYTE,REG_VACIO;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,REG_VACIO;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,REG_VACIO;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR

RETIRADA:
RET;SI EL RESTO ES MENOR O IGUAL A LA MITAD DEL DIVISOR, TERMINO LA DIVISION POR COMPLETO
