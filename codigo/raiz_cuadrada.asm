;Raiz cuadrada
;Los registros R0:R3 se pueden borrar ya que corresponden al valor a aplicarle la raiz cuadrada

.include "m328pdef.inc"

.DEF CUADRADO_4toBYTE = R0
.DEF CUADRADO_3erBYTE = R1
.DEF CUADRADO_2doBYTE = R2
.DEF CUADRADO_1erBYTE = R3
.DEF DIVIDENDO_4toBYTE = R4
.DEF DIVIDENDO_3erBYTE = R5
.DEF DIVIDENDO_2doBYTE = R6
.DEF DIVIDENDO_1erBYTE = R7
.DEF COCIENTE_4toBYTE = R8
.DEF COCIENTE_3erBYTE = R9
.DEF COCIENTE_2doBYTE = R10
.DEF COCIENTE_1erBYTE = R11
.DEF DIVISOR_4toBYTE = R12
.DEF DIVISOR_3erBYTE = R13
.DEF DIVISOR_2doBYTE = R14
.DEF DIVISOR_1erBYTE = R15
.DEF TEMP = R16
.DEF CONT_ITERACIONES = R17
.DEF INIT_CUADRADO_4toBYTE = R18
.DEF INIT_CUADRADO_3erBYTE = R19
.DEF INIT_CUADRADO_2doBYTE = R20
.DEF INIT_CUADRADO_1erBYTE = R21
.DEF FALTA_RESTA = R22

.CSEG
	RJMP MAIN

.EQU CANT_ITERACIONES = 16
.EQU FRESTA_2doBYTE = 0
.EQU FRESTA_3erBYTE = 1
.EQU FRESTA_4toBYTE = 2

.ORG INT_VECTORS_SIZE

MAIN:
;INICIALIZACION STACK
	LDI TEMP,HIGH(RAMEND)
	OUT SPH,TEMP
	LDI TEMP,LOW(RAMEND)
	OUT SPL,TEMP
;[FIN]INICIALIZACION STACK

	CALL RAIZ_CUADRADA
HERE:RJMP HERE

RAIZ_CUADRADA:
	LDI TEMP,0x25
	MOV CUADRADO_4toBYTE,TEMP
	LDI TEMP,0x58
	MOV CUADRADO_3erBYTE,TEMP
	LDI TEMP,0x42
	MOV CUADRADO_2doBYTE,TEMP
	LDI TEMP,0x10
	MOV CUADRADO_1erBYTE,TEMP

	LDI INIT_CUADRADO_2doBYTE,0xFF;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO
	LDI INIT_CUADRADO_1erBYTE,0xFF;GUARDO EL VALOR DEL 3er BYTE DEL CUADRADO

	LDI CONT_ITERACIONES,CANT_ITERACIONES;CARGO LA CANTIDAD DE ITERACIONES

	CLR TEMP
COMPARAR_1erBYTE:
	CP CUADRADO_1erBYTE,TEMP
	BRNE COMPARAR_2doBYTE
	LDI INIT_CUADRADO_1erBYTE,0x0F;GUARDO EL VALOR DEL 3er BYTE DEL CUADRADO
COMPARAR_2doBYTE:
	CP CUADRADO_2doBYTE,TEMP
	BRNE COMPARAR_3erBYTE
	ANDI INIT_CUADRADO_1erBYTE,0xF0;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO
COMPARAR_3erBYTE:
	CP CUADRADO_3erBYTE,TEMP
	BRNE COMPARAR_4toBYTE
	ANDI INIT_CUADRADO_2doBYTE,0x0F;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO
COMPARAR_4toBYTE:
	CP CUADRADO_4toBYTE,TEMP
	BRNE ITERACION_RAIZ
	ANDI INIT_CUADRADO_2doBYTE,0xF0;GUARDO EL VALOR DEL 4to BYTE DEL CUADRADO

ITERACION_RAIZ:
	CALL RAIZ_NR
	DEC CONT_ITERACIONES
	BRNE ITERACION_RAIZ
RET

RAIZ_NR:
	;a
	MOVW DIVIDENDO_3erBYTE:DIVIDENDO_4toBYTE,CUADRADO_3erBYTE:CUADRADO_4toBYTE
	MOVW DIVIDENDO_1erBYTE:DIVIDENDO_2doBYTE,CUADRADO_1erBYTE:CUADRADO_2doBYTE
	;[FIN]a
	;X(k)
	MOVW DIVISOR_3erBYTE:DIVISOR_4toBYTE,INIT_CUADRADO_3erBYTE:INIT_CUADRADO_4toBYTE
	MOVW DIVISOR_1erBYTE:DIVISOR_2doBYTE,INIT_CUADRADO_1erBYTE:INIT_CUADRADO_2doBYTE
	;[FIN]X(k)
	CALL DIVISION;a/X(k)
	;X(k) + a/X(k)
	ADD INIT_CUADRADO_1erBYTE,COCIENTE_1erBYTE
	ADC INIT_CUADRADO_2doBYTE,COCIENTE_2doBYTE
	ADC INIT_CUADRADO_3erBYTE,COCIENTE_3erBYTE
	ADC INIT_CUADRADO_4toBYTE,COCIENTE_4toBYTE
	;[FIN]X(k) + a/X(k)
	;(X(k) + a/X(k))/2
	LSR INIT_CUADRADO_4toBYTE
	ROR INIT_CUADRADO_3erBYTE
	ROR INIT_CUADRADO_2doBYTE
	ROR INIT_CUADRADO_1erBYTE
	;[FIN](X(k) + a/X(k))/2
RET

DIVISION:
	CLR COCIENTE_4toBYTE
	CLR COCIENTE_3erBYTE
	CLR COCIENTE_2doBYTE
	CLR COCIENTE_1erBYTE

;[RESTA]
RESTA_1erBYTE:
	ORI FALTA_RESTA,(1<<FRESTA_2doBYTE)|(1<<FRESTA_3erBYTE)|(1<<FRESTA_4toBYTE)
	SUB DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;LE RESTO AL 1er BYTE DEL DIVIDENDO EL 1er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_2doBYTE;SI EL 1er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 2do BYTE
RESTA_2doBYTE:
	ANDI FALTA_RESTA,~(1<<FRESTA_2doBYTE)
	SUB DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;LE RESTO AL 2do BYTE DEL DIVIDENDO EL 2do BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 3er BYTE
RESTA_3erBYTE:
	ANDI FALTA_RESTA,~(1<<FRESTA_3erBYTE)
	SUB DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;LE RESTO AL 3er BYTE DEL DIVIDENDO EL 3er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 4to BYTE
RESTA_4toBYTE:
	ANDI FALTA_RESTA,~(1<<FRESTA_4toBYTE)
	SUB DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;LE RESTO AL 4to BYTE DEL DIVIDENDO EL 4to BYTE DEL DIVIDENDO
	BRCS REDONDEO;SI EL 4to BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO
;[RESTA]

;[INCREMENTO COCIENTE]
INCREMENTAR_RESULTADO:
	LDI TEMP,1
	ADD COCIENTE_1erBYTE,TEMP;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	CLR TEMP
	ADC COCIENTE_2doBYTE,TEMP;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,TEMP;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,TEMP;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR
	RJMP RESTA_1erBYTE;VUELVO A COMENZAR EL PROCESO DE DIVISION
;[INCREMENTO COCIENTE]

;[CARRY]
PEDIDO_CARRY_2doBYTE:
	CLR TEMP
	CP DIVIDENDO_2doBYTE,TEMP;REVISO SI EL 2do BYTE ES NULO
	BRNE CARRY_2doBYTE;SI EL 2do BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 3er BYTE
CARRY_2doBYTE:
	DEC DIVIDENDO_2doBYTE;RESTO EN UNO EL 2do BYTE
	RJMP RESTA_2doBYTE;VUELVO A LAS RESTAS SUCESIVAS

PEDIDO_CARRY_3erBYTE:
	CLR TEMP
	CP DIVIDENDO_3erBYTE,TEMP;REVISO SI EL 3er BYTE ES NULO
	BRNE CARRY_3erBYTE;SI EL 3er BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 4to BYTE
CARRY_3erBYTE:
	DEC DIVIDENDO_3erBYTE;RESTO EN UNO EL 3er BYTE
	SBRC FALTA_RESTA,FRESTA_2doBYTE
	RJMP CARRY_2doBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_3erBYTE;VUELVO LAS RESTAS SUCESIVAS

PEDIDO_CARRY_4toBYTE:
	CLR TEMP
	CP DIVIDENDO_4toBYTE,TEMP;REVISO SI EL 4to BYTE ES NULO
	BRNE CARRY_4toBYTE;SI EL 4to BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP REDONDEO;SI EL 4to BYTE ES NULO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO
CARRY_4toBYTE:
	DEC DIVIDENDO_4toBYTE;RESTO EN UNO EL 4to BYTE
	SBRC FALTA_RESTA,FRESTA_3erBYTE
	RJMP CARRY_3erBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_4toBYTE;VUELVO LAS RESTAS SUCESIVAS
;[CARRY]

;[REDONDEO]
REDONDEO:
	ADD DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;REESTABLEZCO EL VALOR DEL 1er BYTE ANTES DE RESTARLO DE MAS
REVISAR_2doBYTE:
	SBRC FALTA_RESTA,FRESTA_2doBYTE
	RJMP REVISAR_3erBYTE
	ADD DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;REESTABLEZCO EL VALOR DEL 2do BYTE ANTES DE RESTARLO DE MAS
REVISAR_3erBYTE:
	SBRC FALTA_RESTA,FRESTA_3erBYTE
	RJMP REVISAR_4toBYTE
	ADD DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;REESTABLEZCO EL VALOR DEL 3er BYTE ANTES DE RESTARLO DE MAS
REVISAR_4toBYTE:
	SBRC FALTA_RESTA,FRESTA_3erBYTE
	RJMP CHEQUEAR_REDONDEO
	ADD DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;REESTABLEZCO EL VALOR DEL 4to BYTE ANTES DE RESTARLO DE MAS

CHEQUEAR_REDONDEO:
	;DIVIDO POR DOS EL DIVISOR
	LSR DIVISOR_4toBYTE
	ROR DIVISOR_3erBYTE
	ROR DIVISOR_2doBYTE
	ROR DIVISOR_1erBYTE
	;[FIN]DIVIDO POR DOS EL DIVISOR
	;CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
	CP DIVIDENDO_4toBYTE,DIVISOR_4toBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_3erBYTE,DIVISOR_3erBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_2doBYTE,DIVISOR_2doBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_1erBYTE,DIVISOR_1erBYTE
	BRPL MODIFICAR_COCIENTE
	RJMP RETIRADA
	;[FIN]CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
MODIFICAR_COCIENTE:;SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR, REDONDEO PARA ARRIBA EL COCIENTE
	LDI TEMP,1
	ADD COCIENTE_1erBYTE,TEMP;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	CLR TEMP
	ADC COCIENTE_2doBYTE,TEMP;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,TEMP;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,TEMP;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR
;[REDONDEO]

RETIRADA:
RET;SI EL RESTO ES MENOR O IGUAL A LA MITAD DEL DIVISOR, TERMINO LA DIVISION POR COMPLETO
