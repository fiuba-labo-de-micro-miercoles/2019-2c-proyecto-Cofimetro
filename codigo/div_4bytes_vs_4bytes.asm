.include "m328pdef.inc"

.DEF REG_VACIO = R2
.DEF FALTA_RESTA_2doBYTE = R3
.DEF FALTA_RESTA_3erBYTE = R4
.DEF FALTA_RESTA_4toBYTE = R5
.DEF REDONDEO_4toBYTE = R6
.DEF REDONDEO_3erBYTE = R7
.DEF REDONDEO_2doBYTE = R8
.DEF REDONDEO_1erBYTE = R9
.DEF DIVISOR_4toBYTE = R26
.DEF DIVISOR_3erBYTE = R27
.DEF DIVISOR_2doBYTE = R28
.DEF DIVISOR_1erBYTE = R29
.DEF REG_UNO = R16
.DEF DIVIDENDO_4toBYTE = R17
.DEF DIVIDENDO_3erBYTE = R18
.DEF DIVIDENDO_2doBYTE = R19
.DEF DIVIDENDO_1erBYTE = R20
.DEF TEMP = R21
.DEF COCIENTE_4toBYTE = R22
.DEF COCIENTE_3erBYTE = R23
.DEF COCIENTE_2doBYTE = R24
.DEF COCIENTE_1erBYTE = R25

.CSEG
	RJMP MAIN

.ORG INT_VECTORS_SIZE

MAIN:
;INICIALIZACION STACK
	LDI TEMP,HIGH(RAMEND)
	OUT SPH,TEMP
	LDI TEMP,LOW(RAMEND)
	OUT SPL,R16
;[FIN]INICIALIZACION STACK

	CLR REG_VACIO;VALOR NULO
	LDI REG_UNO,1;CARGO UN VALOR CON 1
	LDI DIVIDENDO_4toBYTE,0x07
	LDI DIVIDENDO_3erBYTE,0x03
	LDI DIVIDENDO_2doBYTE,0x03
	LDI DIVIDENDO_1erBYTE,0x04
	LDI DIVISOR_4toBYTE,0x01
	LDI DIVISOR_3erBYTE,0x04
	LDI DIVISOR_2doBYTE,0x03
	LDI DIVISOR_1erBYTE,0x04
	CLR TEMP
	CALL RESTA_1erBYTE;ARRANCO DIVISION
HERE:RJMP HERE

RESTA_1erBYTE:
	ADD FALTA_RESTA_2doBYTE,REG_UNO;AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 2do BYTE
	ADD FALTA_RESTA_3erBYTE,REG_UNO;AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 3er BYTE
	ADD FALTA_RESTA_4toBYTE,REG_UNO;AVISO QUE TODAVIA NO SE REALIZO LA RESTA DEL 4to BYTE
	SUB DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;LE RESTO AL 1er BYTE DEL DIVIDENDO EL 1er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_2doBYTE;SI EL 1er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 2do BYTE
RESTA_2doBYTE:
	CLR FALTA_RESTA_2doBYTE;AVISO QUE SE REALIZO LA RESTA DEL 2do BYTE
	SUB DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;LE RESTO AL 2do BYTE DEL DIVIDENDO EL 2do BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 3er BYTE
RESTA_3erBYTE:
	CLR FALTA_RESTA_3erBYTE;AVISO QUE SE REALIZO LA RESTA DEL 3er BYTE
	SUB DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;LE RESTO AL 3er BYTE DEL DIVIDENDO EL 3er BYTE DEL DIVIDENDO
	BRCS PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, LE PIDO UNO AL 4to BYTE
RESTA_4toBYTE:
	CLR FALTA_RESTA_4toBYTE;AVISO QUE SE REALIZO LA RESTA DEL 4to BYTE
	SUB DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;LE RESTO AL 4to BYTE DEL DIVIDENDO EL 4to BYTE DEL DIVIDENDO
	BRCS REDONDEO;SI EL 4to BYTE DEL DIVISOR ES MAYOR AL DE DIVIDENDO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO

INCREMENTAR_RESULTADO:
	ADD COCIENTE_1erBYTE,REG_UNO;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	ADC COCIENTE_2doBYTE,REG_VACIO;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,REG_VACIO;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,REG_VACIO;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR
	RJMP RESTA_1erBYTE;VUELVO A COMENZAR EL PROCESO DE DIVISION

PEDIDO_CARRY_2doBYTE:
	CPI DIVIDENDO_2doBYTE,0;REVISO SI EL 2do BYTE ES NULO
	BRNE CARRY_2doBYTE;SI EL 2do BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_3erBYTE;SI EL 2do BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 3er BYTE
CARRY_2doBYTE:
	DEC DIVIDENDO_2doBYTE;RESTO EN UNO EL 2do BYTE
	RJMP RESTA_2doBYTE;VUELVO A LAS RESTAS SUCESIVAS

PEDIDO_CARRY_3erBYTE:
	CPI DIVIDENDO_3erBYTE,0;REVISO SI EL 3er BYTE ES NULO
	BRNE CARRY_3erBYTE;SI EL 3er BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP PEDIDO_CARRY_4toBYTE;SI EL 3er BYTE ES NULO, ENTONCES PASO A OPERAR CON EL 4to BYTE
CARRY_3erBYTE:
	DEC DIVIDENDO_3erBYTE;RESTO EN UNO EL 3er BYTE
	CP FALTA_RESTA_2doBYTE,REG_VACIO;REVISO SI QUEDO PENDIENTE LA RESTA DEL 2do BYTE
	BRNE CARRY_2doBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_3erBYTE;VUELVO LAS RESTAS SUCESIVAS

PEDIDO_CARRY_4toBYTE:
	CPI DIVIDENDO_4toBYTE,0;REVISO SI EL 4to BYTE ES NULO
	BRNE CARRY_4toBYTE;SI EL 4to BYTE NO ES NULO, PROCEDO A RESTARLO EN UNO Y SEGUIR RESTANDO EL 1er BYTE
	RJMP REDONDEO;SI EL 4to BYTE ES NULO, PROCEDO A TERMINAR LA DIVISION Y PASAR AL REDONDEO SIMETRICO
CARRY_4toBYTE:
	DEC DIVIDENDO_4toBYTE;RESTO EN UNO EL 4to BYTE
	CP FALTA_RESTA_3erBYTE,REG_VACIO;REVISO SI QUEDO PENDIENTE LA RESTA DEL 3er BYTE
	BRNE CARRY_3erBYTE;VUELVO AL CARRY DEL 2do BYTE
	RJMP RESTA_4toBYTE;VUELVO LAS RESTAS SUCESIVAS

REDONDEO:
	ADD DIVIDENDO_1erBYTE,DIVISOR_1erBYTE;REESTABLEZCO EL VALOR DEL 1er BYTE ANTES DE RESTARLO DE MAS
REVISAR_2doBYTE:
	CP FALTA_RESTA_2doBYTE,REG_VACIO;REVISO SI HICE UNA RESTA DE MAS EN EL 2do BYTE
	BREQ REVISAR_3erBYTE;SI NO HICE UNA RESTA DE MAS EN EL 2do BYTE, PROCEDO A REVISAR EN EL 3er BYTE
	ADD DIVIDENDO_2doBYTE,DIVISOR_2doBYTE;REESTABLEZCO EL VALOR DEL 2do BYTE ANTES DE RESTARLO DE MAS
REVISAR_3erBYTE:
	CP FALTA_RESTA_3erBYTE,REG_VACIO;REVISO SI HICE UNA RESTA DE MAS EN EL 3er BYTE
	BREQ REVISAR_4toBYTE;SI NO HICE UNA RESTA DE MAS EN EL 3er BYTE, PROCEDO A REVISAR EN EL 4to BYTE
	ADD DIVIDENDO_3erBYTE,DIVISOR_3erBYTE;REESTABLEZCO EL VALOR DEL 3er BYTE ANTES DE RESTARLO DE MAS
REVISAR_4toBYTE:
	CP FALTA_RESTA_4toBYTE,REG_VACIO;REVISO SI HICE UNA RESTA DE MAS EN EL 4to BYTE
	BREQ CHEQUEAR_REDONDEO;SI NO HICE UNA RESTA DE MAS EN EL 3er BYTE, PROCEDO A COMENZAR EL REDONDEO
	ADD DIVIDENDO_4toBYTE,DIVISOR_4toBYTE;REESTABLEZCO EL VALOR DEL 4to BYTE ANTES DE RESTARLO DE MAS

CHEQUEAR_REDONDEO:
	MOV REDONDEO_4toBYTE,DIVISOR_4toBYTE;GUARDO EL VALOR DEL 4to BYTE DEL DIVISOR
	MOV REDONDEO_3erBYTE,DIVISOR_3erBYTE;GUARDO EL VALOR DEL 3er BYTE DEL DIVISOR
	MOV REDONDEO_2doBYTE,DIVISOR_2doBYTE;GUARDO EL VALOR DEL 2do BYTE DEL DIVISOR
	MOV REDONDEO_1erBYTE,DIVISOR_1erBYTE;GUARDO EL VALOR DEL 1er BYTE DEL DIVISOR
	;DIVIDO POR DOS EL DIVISOR
	LSR REDONDEO_4toBYTE
	ROR REDONDEO_3erBYTE
	ROR REDONDEO_2doBYTE
	ROR REDONDEO_1erBYTE
	;[FIN]DIVIDO POR DOS EL DIVISOR
	;CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
	CP DIVIDENDO_4toBYTE,REDONDEO_4toBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_3erBYTE,REDONDEO_3erBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_2doBYTE,REDONDEO_2doBYTE
	BRLO RETIRADA
	BRPL MODIFICAR_COCIENTE
	CP DIVIDENDO_1erBYTE,REDONDEO_1erBYTE
	BRPL MODIFICAR_COCIENTE
	RJMP RETIRADA
	;[FIN]CHEQUEO SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR
MODIFICAR_COCIENTE:;SI EL RESTO ES MAYOR A LA MITAD DEL DIVISOR, REDONDEO PARA ARRIBA EL COCIENTE
	ADD COCIENTE_1erBYTE,REG_UNO;INCREMENTO EN UNO EL RESULTADO DE LA DIVISION ENTRE EL SUMADOR Y LA CANTIDAD DE LETRAS/NUMEROS
	ADC COCIENTE_2doBYTE,REG_VACIO;SI HAY CARRY DEL 1er BYTE SE LO SUMO AL 2do BYTE DEL CONTADOR
	ADC COCIENTE_3erBYTE,REG_VACIO;SI HAY CARRY DEL 2do BYTE SE LO SUMO AL 3er BYTE DEL CONTADOR
	ADC COCIENTE_4toBYTE,REG_VACIO;SI HAY CARRY DEL 3er BYTE SE LO SUMO AL 4to BYTE DEL CONTADOR

RETIRADA:
RET;SI EL RESTO ES MENOR O IGUAL A LA MITAD DEL DIVISOR, TERMINO LA DIVISION POR COMPLETO
